## 시간복잡도란?

시간복잡도(Time Complexity)는 **알고리즘이나 자료구조가 입력값의 크기(n)에 따라 얼마나 많은 시간이 걸리는지**를 수학적으로 나타내는 척도. 즉, 입력 데이터가 커질수록 연산이 얼마나 더 오래 걸리는지를 예측할 수 있게 해준다.

## 왜 시간복잡도가 중요한가?

- 효율적인 프로그램을 만들기 위해서는 단순히 동작하는 코드가 아니라, **입력값이 커져도 빠르게 동작하는 코드**를 짜야 한다.
- 시간복잡도를 고려하지 않으면, 입력값이 많아졌을 때 프로그램이 매우 느려지거나 아예 동작하지 않을 수 있다.


## 시간복잡도 표기법 (Big-O)

시간복잡도는 주로 **Big-O 표기법**을 사용하여 표현한다. 이는 최악의 경우(가장 오래 걸리는 경우)를 기준으로 알고리즘의 실행시간을 나타낸다.


| 표기 | 의미 | 예시 |
| :-- | :-- | :-- |
| O(1) | 상수 시간 | 리스트에서 인덱스로 값 읽기, 딕셔너리 조회 |
| O(log n) | 로그 시간 | 이진 탐색 |
| O(n) | 선형 시간 | 리스트 전체 순회 |
| O(n log n) | 선형로그 | 퀵 정렬, 병합 정렬 |
| O(n²) | 2차 시간 | 이중 for문, 버블 정렬 |
| O(2ⁿ) | 지수 시간 | 피보나치(재귀) |
| O(n!) | 팩토리얼 | 순열 생성 |

- 아래로 갈수록 연산량이 급격히 증가하므로, **O(1), O(log n), O(n)** 처럼 낮은 복잡도가 더 좋은 알고리즘.


## 파이썬 자료구조별 주요 연산의 시간복잡도

자료구조에 따라 같은 작업도 시간복잡도가 다를 수 있다.


| 연산 | 리스트(List) | 집합(Set) | 딕셔너리(Dictionary) |
| :-- | :-- | :-- | :-- |
| 값 추가 | O(1) | O(1) | O(1) |
| 값 삭제 | O(n) | O(1) | O(1) |
| 값 탐색(in) | O(n) | O(1) | O(1) |
| 인덱스 접근 | O(1) | - | - |
| 전체 순회 | O(n) | O(n) | O(n) |
| 정렬 | O(n log n) | - | - |

- **리스트**는 인덱스 접근이 빠르지만, 값 탐색(in)이나 중간 삽입/삭제는 느리다.
- **집합/딕셔너리**는 해시 구조라서 값 추가, 삭제, 탐색이 매우 빠르다.


## 시간복잡도 예시 (파이썬 코드)

```python
# O(1) 예시: 리스트에서 인덱스로 값 읽기
lst = [1, 2, 3, 4, 5]
print(lst[^1_2])  # 3

# O(n) 예시: 리스트 전체 순회
for item in lst:
    print(item)

# O(n^2) 예시: 이중 for문
for i in range(len(lst)):
    for j in range(len(lst)):
        print(lst[i], lst[j])
```


## 정리

- **시간복잡도는 입력 크기에 따라 알고리즘이 얼마나 빨리(또는 느리게) 동작하는지 나타내는 지표**.
- 효율적인 코드를 짜려면, 각 자료구조와 연산의 시간복잡도를 이해하고, 상황에 맞게 적절한 자료구조를 선택해야 한다.
- 코딩테스트나 실제 개발에서 시간복잡도를 고려하지 않으면, 입력이 많아졌을 때 프로그램이 심각하게 느려질 수 있다.
